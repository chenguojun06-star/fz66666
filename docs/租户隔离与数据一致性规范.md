# 租户隔离与数据一致性规范（强制执行）

> **核心原则**：数据隔离 = 所有操作都带 tenant_id | 数据一致性 = 同一 tenant_id 内的操作必须原子性
> **最后更新**：2026-02-15 | **版本**：v1.0

---

## 一、系统架构概述

### 租户隔离技术栈
```
请求 → JWT认证(TokenAuthFilter) → 用户上下文(UserContextInterceptor)
  → UserContext.set(tenantId) → TenantInterceptor(SQL改写)
  → MyBatisPlusMetaObjectHandler(INSERT自动填充)
```

### 隔离层级
| 层级 | 组件 | 机制 |
|------|------|------|
| **SQL层** | TenantInterceptor | SELECT/UPDATE/DELETE 自动追加 `WHERE tenant_id = X` |
| **INSERT层** | MetaObjectHandler | 自动填充 `tenant_id` 字段 |
| **业务层** | TenantAssert | 运行时校验租户上下文和数据归属 |
| **权限层** | @PreAuthorize | Controller 方法级权限控制 |

---

## 二、六条铁律（开发口诀）

### 1. 无 tenant_id，不执行 SQL
```java
// ✅ 正确：TenantInterceptor 自动处理
// 不需要手动加 WHERE tenant_id = X

// ⚠️ 但必须确保 UserContext 有值：
TenantAssert.assertTenantContext(); // 在 Orchestrator 入口调用
```

### 2. 无 tenant_id，不发送 MQ（未来扩展）
```java
// MQ 消息体必须包含 tenantId
message.setTenantId(UserContext.tenantId());

// 消费者必须先绑定上下文
TenantAssert.bindTenantForTask(msg.getTenantId(), "订单同步");
try {
    // 业务逻辑
} finally {
    TenantAssert.clearTenantContext();
}
```

### 3. 无 tenant_id，不开启事务
```java
// ✅ 正确：Orchestrator 事务方法第一行
@Transactional(rollbackFor = Exception.class)
public void createOrder(...) {
    TenantAssert.assertTenantContext(); // 必须是第一行！
    // ... 业务逻辑
}
```

### 4. 联表先匹配 tenant_id，再关联业务ID
```sql
-- ✅ 正确：TenantInterceptor 会自动给所有 FROM/JOIN 的表追加 tenant_id 条件
-- 不需要手动写 ON o.tenant_id = oi.tenant_id
-- 拦截器通过正则 (?:FROM|JOIN)\s+table_name 识别并追加

-- ⚠️ 注意：如果使用原生 SQL（@Select 注解），拦截器同样会处理
-- ❌ 但如果 SQL 中的表名在 EXCLUDED_TABLES 中，则不会追加
```

### 5. 一个事务，只允许一个租户
```java
// ✅ 正确：事务内所有操作使用同一 UserContext
@Transactional(rollbackFor = Exception.class)
public void createOrder(OrderRequest req) {
    Long tenantId = TenantAssert.requireTenantId();
    
    orderService.create(order);           // tenant_id = 1
    materialStockService.deduct(stock);   // tenant_id = 1
    scanRecordService.init(record);       // tenant_id = 1
    // 所有操作同一租户，INSERT 自动填充同一 tenantId
}

// ❌ 禁止：手动切换 UserContext
UserContext ctx = new UserContext();
ctx.setTenantId(2L);  // ❌ 禁止在事务中切换租户！
UserContext.set(ctx);
```

### 6. 异步、定时、导出，全按租户跑
```java
// ✅ 正确：定时任务按租户遍历
@Scheduled(cron = "0 0 2 * * ?")
public void dailyReport() {
    List<Tenant> tenants = tenantService.listAll();
    for (Tenant t : tenants) {
        TenantAssert.bindTenantForTask(t.getId(), "日报生成");
        try {
            generateDailyReport(t.getId());
        } finally {
            TenantAssert.clearTenantContext();
        }
    }
}
```

---

## 三、TenantAssert 使用指南

### 工具类位置
`com.fashion.supplychain.common.tenant.TenantAssert`

### API 速查

| 方法 | 用途 | 典型场景 |
|------|------|---------|
| `assertTenantContext()` | 断言有租户上下文 | Orchestrator @Transactional 方法入口 |
| `requireTenantId()` | 返回非null的tenantId | 需要用 tenantId 做业务逻辑 |
| `requireTenantIdOrSuperAdmin()` | 允许超管绕过 | 超管可跨租户操作的场景 |
| `assertBelongsToCurrentTenant(entityTid, desc)` | 校验实体归属 | 更新/删除前验证 |
| `assertSameTenant(tenantIds, op)` | 断言同一租户 | 事务内多实体操作 |
| `assertAllBelongToCurrentTenant(tids, op)` | 批量归属校验 | 批量删除/更新 |
| `bindTenantForTask(tenantId, taskName)` | 绑定异步任务上下文 | 定时任务/MQ消费者 |
| `clearTenantContext()` | 清除上下文 | finally 块中调用 |

### 在 Orchestrator 中使用

```java
@Service
@Slf4j
public class ProductionOrderOrchestrator {

    @Transactional(rollbackFor = Exception.class)
    public Map<String, Object> createOrderFromStyle(String styleId, ...) {
        TenantAssert.assertTenantContext(); // ← 第一行！
        
        // 业务逻辑...
        StyleInfo style = styleInfoService.getById(styleId);
        TenantAssert.assertBelongsToCurrentTenant(
            style.getTenantId(), "款式信息"
        ); // ← 操作前校验归属
        
        // 创建订单（INSERT 自动填充 tenantId）
        productionOrderService.save(order);
        return result;
    }
}
```

---

## 四、已应用 TenantAssert 的 Orchestrator

### P0 核心业务（已保护）
| Orchestrator | 保护方法 | 用途 |
|---|---|---|
| `ScanRecordOrchestrator` | execute, undo, rescan | 扫码（最高频） |
| `ProductionOrderOrchestrator` | scrapOrder, closeOrder, createOrderFromStyle, confirmProcurement | 订单生命周期 |
| `MaterialInboundOrchestrator` | confirmArrivalAndInbound | 面辅料入库 |
| `ProductWarehousingOrchestrator` | save, batchSave | 成品入库 |
| `PayrollSettlementOrchestrator` | generate | 工资结算 |

### 待添加（P1，按需补充）
- ExpenseReimbursementOrchestrator（报销审批）
- ShipmentReconciliationOrchestrator（出货对账）
- MaterialPurchaseOrchestrator（采购操作）
- CuttingTaskOrchestrator（裁剪任务）
- StyleBomOrchestrator（BOM管理）

### 添加规则
**所有新的 `@Transactional` 方法，第一行必须调用 `TenantAssert.assertTenantContext()`**

---

## 五、数据库表 tenant_id 覆盖率

### 统计（2026-02-15）
- **总计 57 张表**
- **49 张有 tenant_id** ✅
- **8 张无 tenant_id**（全部在 EXCLUDED_TABLES 中）

### 排除表列表（不需要 tenant_id）
| 表名 | 原因 | 安全评级 |
|------|------|---------|
| t_tenant | 租户表本身 | ✅ |
| t_permission | 全局权限定义 | ✅ |
| t_role_permission | 角色-权限关联 | ✅ |
| t_login_log | 登录日志（审计用） | ✅ |
| t_dict | 数据字典（全局共享） | ✅ |
| t_param_config | 系统参数（全局共享） | ✅ |
| t_serial_rule | 序列号规则 | ✅ |
| t_app_store | 应用商店 | ✅ |

### 共享表（SHARED_TENANT_TABLES）
| 表名 | 机制 | 说明 |
|------|------|------|
| t_role | `tenant_id = X OR tenant_id IS NULL` | 模板角色(NULL) + 租户角色 |
| t_template_library | 同上 | 系统模板(NULL) + 租户模板 |
| t_template_operation_log | 同上 | 模板操作日志 |

### 新增表规范
```sql
-- ✅ 必须包含以下字段
CREATE TABLE t_new_table (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    -- 业务字段...
    tenant_id BIGINT NOT NULL COMMENT '租户ID',
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    delete_flag INT DEFAULT 0,
    INDEX idx_tenant_id (tenant_id)
);
```

```java
// ✅ 对应实体类必须包含
@TableField(fill = FieldFill.INSERT)
private Long tenantId;
```

---

## 六、乐观锁机制（并发安全）

### 已启用乐观锁的表
| 表名 | 用途 | @Version |
|------|------|---------|
| t_material_stock | 面辅料库存 | ✅ `MaterialStock.version` |
| t_sample_stock | 样衣库存 | ✅ `SampleStock.version` |
| t_production_order | 生产订单 | ✅ `ProductionOrder.version` |

### 乐观锁工作原理
```sql
-- MyBatis-Plus @Version 自动处理
UPDATE t_material_stock
SET quantity = quantity - 10, version = version + 1
WHERE id = ? AND tenant_id = ? AND version = ?
-- version 不匹配 → 更新 0 行 → 抛出 OptimisticLockerException
```

### 什么场景需要乐观锁？
- ✅ **库存增减**（并发扫码、并发入库）
- ✅ **订单状态变更**（避免重复关闭/报废）
- ✅ **数量计算**（防止多人同时操作覆盖）
- ❌ 不需要：只读查询、日志记录、配置修改

---

## 七、服装供应链最易崩的 4 个场景

### 场景1：生产单 + 扫码计件
**问题**：多工厂、多工人同时扫码，容易多算/少算

**当前保护机制**：
1. `ScanRecord.requestId` 唯一索引 → 物理去重
2. `DuplicateScanPreventer` → 防重复提交（时间间隔算法）
3. `TenantInterceptor` → SQL 级隔离
4. `TenantAssert.assertTenantContext()` → 业务级断言

### 场景2：订单 → 生产单 → 采购单（链条一致性）
**当前保护机制**：
1. `@Transactional` 在 Orchestrator 层 → 链条原子性
2. `TenantAssert` → 确保链条中所有实体同一租户
3. 乐观锁 → 订单状态变更不冲突

### 场景3：库存并发操作
**当前保护机制**：
1. `@Version` 乐观锁 → 并发安全
2. `TenantInterceptor` → 隔离
3. `MaterialStockOrchestrator` → 编排库存操作

### 场景4：财务结算
**当前保护机制**：
1. `PayrollSettlementOrchestrator.generate()` → TenantAssert 保护
2. 扫码记录聚合按 tenant_id 自动过滤
3. 结算审批状态机 → 防止重复结算

---

## 八、代码审查清单（Checklist）

### 新增 Orchestrator 方法
- [ ] `@Transactional` 方法第一行是否有 `TenantAssert.assertTenantContext()`？
- [ ] 操作他人传入的 ID 前，是否校验了 `assertBelongsToCurrentTenant()`？
- [ ] 批量操作是否验证了 `assertAllBelongToCurrentTenant()`？

### 新增数据库表
- [ ] 是否包含 `tenant_id BIGINT NOT NULL` 字段？
- [ ] 是否在实体类中添加了 `@TableField(fill = FieldFill.INSERT) private Long tenantId`？
- [ ] 是否创建了 `INDEX idx_tenant_id (tenant_id)` 索引？
- [ ] 如果涉及并发操作，是否添加了 `version INT DEFAULT 0` + `@Version`？

### 新增 Service 方法
- [ ] 是否通过 MyBatis-Plus API（LambdaQueryWrapper）构建查询？（TenantInterceptor 自动处理）
- [ ] 如果使用原生 SQL，是否确认 TenantInterceptor 能正确解析？

### 新增 Controller 方法
- [ ] 是否添加了 `@PreAuthorize` 权限注解？
- [ ] 是否避免了 `permitAll()`？

---

## 九、TenantInterceptor 技术细节

### SQL 改写机制
```
原始 SQL: SELECT * FROM t_production_order WHERE status = 'active'
改写后:   SELECT * FROM t_production_order WHERE status = 'active' AND tenant_id = 1
```

### 子查询安全
拦截器使用**括号深度追踪**算法（`findFirstAtDepthZero`），确保只匹配最外层 SQL 关键字：
```
✅ SELECT * FROM t (SELECT ... WHERE ... ORDER BY ... LIMIT 1) WHERE ... GROUP BY ...
                                                                 ↑ 插入 tenant_id 在此处
                                                                 （depth=0 的 WHERE）
```

### 共享表处理
```sql
-- 对 SHARED_TENANT_TABLES 中的表
-- 使用 OR tenant_id IS NULL 保留系统共享数据
SELECT * FROM t_role WHERE (tenant_id = 1 OR tenant_id IS NULL)
```

---

## 十、快速参考：文件位置

| 组件 | 路径 |
|------|------|
| TenantInterceptor | `common/tenant/TenantInterceptor.java` |
| TenantAssert | `common/tenant/TenantAssert.java` |
| TenantMetaObjectHandler | `common/tenant/TenantMetaObjectHandler.java` |
| UserContext | `common/UserContext.java` |
| SecurityConfig | `config/SecurityConfig.java` |
| MyBatisPlusConfig | `config/MyBatisPlusConfig.java` |

---

> **开发一句话**：写代码前问自己 —— "这行代码会不会让租户A看到租户B的数据？"
> 如果答案是"可能"，就加 `TenantAssert`。
