# 工序指派工资结算方案

## 背景

当前系统支持将工序指派（委派）给外部工厂或个人，但工资结算逻辑需要完善：
- 如果指派给有账号的人，钱应该算给被指派人
- 如果指派给没有账号的人（如外部工厂），需要记录但不计入内部工资

## 数据库方案

### 1. ScanRecord 表增加字段

```sql
ALTER TABLE t_scan_record 
ADD COLUMN delegate_target_type VARCHAR(20) DEFAULT NULL COMMENT '指派目标类型: internal=内部员工, external=外部工厂, none=未指派',
ADD COLUMN delegate_target_id VARCHAR(64) DEFAULT NULL COMMENT '指派目标ID（员工ID或工厂ID）',
ADD COLUMN delegate_target_name VARCHAR(100) DEFAULT NULL COMMENT '指派目标名称（员工名或工厂名）',
ADD COLUMN actual_operator_id VARCHAR(64) DEFAULT NULL COMMENT '实际操作员ID（谁扫的码）',
ADD COLUMN actual_operator_name VARCHAR(100) DEFAULT NULL COMMENT '实际操作员名称',
ADD INDEX idx_delegate_target (delegate_target_id),
ADD INDEX idx_actual_operator (actual_operator_id);
```

### 2. 字段说明

| 字段 | 说明 | 工资结算逻辑 |
|------|------|-------------|
| `operator_id` | 结算对象ID（用于工资统计） | **优先级最高** - 工资算给这个人 |
| `operator_name` | 结算对象名称 | 显示在工资单上 |
| `delegate_target_type` | 指派类型：`internal`/`external`/`none` | 决定是否计入内部工资 |
| `delegate_target_id` | 被指派人的ID | 如果是内部员工，复制到 `operator_id` |
| `delegate_target_name` | 被指派人的名称 | 显示用 |
| `actual_operator_id` | 实际扫码的人 | 仅追溯用，不影响工资 |
| `actual_operator_name` | 实际扫码的人名 | 仅追溯用 |

## 业务逻辑

### 场景1：指派给内部有账号的员工

**操作流程**：
1. 张三将"车缝"工序指派给李四（李四有账号 `user_123`）
2. 李四扫码完成工序

**数据记录**：
```json
{
  "operator_id": "user_123",           // 李四ID - 工资算给李四
  "operator_name": "李四",
  "delegate_target_type": "internal",  // 内部员工
  "delegate_target_id": "user_123",
  "delegate_target_name": "李四",
  "actual_operator_id": "user_123",    // 李四自己扫的
  "actual_operator_name": "李四",
  "process_name": "车缝",
  "unit_price": 3.50,
  "quantity": 100,
  "scan_cost": 350.00                  // 李四拿350元
}
```

**工资结算**：李四的工资单显示 350元

---

### 场景2：指派给外部工厂（无账号）

**操作流程**：
1. 张三将"刺绣"工序指派给"佳利工厂"（外部，无系统账号）
2. 佳利工厂用临时账号或张三代为扫码

**数据记录**：
```json
{
  "operator_id": null,                  // NULL - 不计入内部工资
  "operator_name": "佳利工厂（外发）",
  "delegate_target_type": "external",   // 外部工厂
  "delegate_target_id": "factory_456",
  "delegate_target_name": "佳利工厂",
  "actual_operator_id": "user_001",     // 张三代扫的
  "actual_operator_name": "张三",
  "process_name": "刺绣",
  "unit_price": 5.00,
  "quantity": 100,
  "scan_cost": 500.00                   // 记录成本但不发工资
}
```

**工资结算**：
- 内部工资单：无此记录（`operator_id` 为空）
- 外发对账单：500元应付给佳利工厂

---

### 场景3：未指派（原有逻辑）

**操作流程**：
1. 张三自己完成"裁剪"工序
2. 张三扫码

**数据记录**：
```json
{
  "operator_id": "user_001",            // 张三ID
  "operator_name": "张三",
  "delegate_target_type": "none",       // 未指派
  "delegate_target_id": null,
  "delegate_target_name": null,
  "actual_operator_id": "user_001",
  "actual_operator_name": "张三",
  "process_name": "裁剪",
  "unit_price": 2.00,
  "quantity": 200,
  "scan_cost": 400.00
}
```

**工资结算**：张三的工资单显示 400元

---

## 前端实现

### 指派弹窗增强

在 `NodeDetailModal.tsx` 中添加指派目标选择：

```typescript
// 指派目标类型
<Select
  placeholder="选择指派对象类型"
  value={delegateTargetType}
  onChange={(value) => setDelegateTargetType(value)}
>
  <Select.Option value="internal">内部员工</Select.Option>
  <Select.Option value="external">外部工厂</Select.Option>
</Select>

// 如果选择内部员工，显示员工选择器
{delegateTargetType === 'internal' && (
  <Select
    placeholder="选择员工"
    showSearch
    filterOption={(input, option) =>
      option?.label.toLowerCase().includes(input.toLowerCase())
    }
    options={employeeList.map(emp => ({
      value: emp.id,
      label: emp.name
    }))}
    onChange={(value, option) => {
      setDelegateTargetId(value);
      setDelegateTargetName(option.label);
    }}
  />
)}

// 如果选择外部工厂，显示工厂选择器
{delegateTargetType === 'external' && (
  <Select
    placeholder="选择工厂"
    options={externalFactoryList.map(factory => ({
      value: factory.id,
      label: factory.name
    }))}
    onChange={(value, option) => {
      setDelegateTargetId(value);
      setDelegateTargetName(option.label);
    }}
  />
)}
```

### 工资明细显示

在 `PayrollOperatorSummary/index.tsx` 中：

```typescript
// 显示列增加指派信息
{
  title: '指派信息',
  dataIndex: 'delegateInfo',
  render: (_, record) => {
    if (record.delegateTargetType === 'none' || !record.delegateTargetType) {
      return <Tag color="default">自己完成</Tag>;
    }
    if (record.delegateTargetType === 'internal') {
      return (
        <Tag color="blue">
          内部指派: {record.delegateTargetName}
        </Tag>
      );
    }
    if (record.delegateTargetType === 'external') {
      return (
        <Tag color="orange">
          外发: {record.delegateTargetName}
        </Tag>
      );
    }
  }
}

// 实际操作员列
{
  title: '实际操作',
  dataIndex: 'actualOperatorName',
  render: (text, record) => {
    if (text && text !== record.operatorName) {
      return (
        <Tooltip title={`由 ${text} 代为扫码`}>
          {text} <InfoCircleOutlined />
        </Tooltip>
      );
    }
    return text || '-';
  }
}
```

## 后端实现

### 1. 扫码时记录指派信息

在 `ScanRecordOrchestrator.java` 中：

```java
public ScanRecord createScanRecord(ScanRecordDTO dto) {
    ScanRecord record = new ScanRecord();
    
    // 获取当前登录用户（实际操作员）
    String currentUserId = SecurityContextHolder.getContext()
        .getAuthentication().getName();
    String currentUserName = getCurrentUserName();
    
    record.setActualOperatorId(currentUserId);
    record.setActualOperatorName(currentUserName);
    
    // 检查该订单的工序是否被指派
    DelegateInfo delegateInfo = getDelegateInfo(dto.getOrderNo(), dto.getProcessName());
    
    if (delegateInfo != null) {
        record.setDelegateTargetType(delegateInfo.getType());
        record.setDelegateTargetId(delegateInfo.getTargetId());
        record.setDelegateTargetName(delegateInfo.getTargetName());
        
        // 如果指派给内部员工，工资算给被指派人
        if ("internal".equals(delegateInfo.getType())) {
            record.setOperatorId(delegateInfo.getTargetId());
            record.setOperatorName(delegateInfo.getTargetName());
        } 
        // 如果外发，operator_id 设为 null，不计入内部工资
        else if ("external".equals(delegateInfo.getType())) {
            record.setOperatorId(null);
            record.setOperatorName(delegateInfo.getTargetName() + "（外发）");
        }
    } else {
        // 未指派，工资算给实际操作员
        record.setDelegateTargetType("none");
        record.setOperatorId(currentUserId);
        record.setOperatorName(currentUserName);
    }
    
    // ... 其他字段设置
    
    return scanRecordService.save(record);
}
```

### 2. 工资查询过滤外发记录

在 `PayrollAggregationOrchestrator.java` 中：

```java
public List<PayrollOperatorProcessSummaryDTO> aggregatePayrollByOperatorAndProcess(...) {
    QueryWrapper<ScanRecord> qw = new QueryWrapper<>();
    
    // ... 其他查询条件
    
    // 只统计内部工资（排除 operator_id 为 null 的外发记录）
    qw.isNotNull("operator_id");
    
    // 可选：如果需要查看外发记录，增加参数 includeExternal
    if (includeExternal) {
        // 不过滤
    }
    
    List<ScanRecord> records = scanRecordService.list(qw);
    // ...
}
```

### 3. 外发对账接口

新增外发工序对账接口：

```java
@GetMapping("/external-delegate-summary")
@PreAuthorize("hasAuthority('FINANCE_VIEW')")
public Result<?> getExternalDelegateSummary(
    @RequestParam(required = false) String factoryId,
    @RequestParam(required = false) LocalDateTime startTime,
    @RequestParam(required = false) LocalDateTime endTime
) {
    QueryWrapper<ScanRecord> qw = new QueryWrapper<>();
    qw.eq("delegate_target_type", "external");
    qw.isNotNull("scan_cost");
    
    if (factoryId != null) {
        qw.eq("delegate_target_id", factoryId);
    }
    if (startTime != null) {
        qw.ge("scan_time", startTime);
    }
    if (endTime != null) {
        qw.le("scan_time", endTime);
    }
    
    List<ScanRecord> records = scanRecordService.list(qw);
    
    // 按工厂分组统计
    Map<String, ExternalFactorySummary> summary = records.stream()
        .collect(Collectors.groupingBy(
            ScanRecord::getDelegateTargetName,
            Collectors.collectingAndThen(
                Collectors.toList(),
                list -> new ExternalFactorySummary(
                    list.get(0).getDelegateTargetId(),
                    list.get(0).getDelegateTargetName(),
                    list.stream().mapToInt(ScanRecord::getQuantity).sum(),
                    list.stream()
                        .map(ScanRecord::getScanCost)
                        .reduce(BigDecimal.ZERO, BigDecimal::add)
                )
            )
        ));
    
    return Result.success(summary.values());
}
```

## 数据迁移

对于历史数据，执行以下脚本：

```sql
-- 将现有数据设置为"未指派"状态
UPDATE t_scan_record 
SET 
    delegate_target_type = 'none',
    actual_operator_id = operator_id,
    actual_operator_name = operator_name
WHERE delegate_target_type IS NULL;
```

## 权限控制

| 角色 | 内部工资 | 外发对账 | 指派权限 |
|------|---------|---------|---------|
| 财务 | ✅ 查看全部 | ✅ 查看全部 | ❌ |
| 生产主管 | ✅ 查看团队 | ✅ 查看全部 | ✅ |
| 普通员工 | ✅ 仅自己 | ❌ | ❌ |

## 总结

**核心原则**：
1. **`operator_id` 决定工资归属**：有值=内部工资，无值=外发成本
2. **`actual_operator_id` 追溯实际操作**：审计用，不影响工资
3. **`delegate_target_type` 区分类型**：`internal` / `external` / `none`
4. **工资查询过滤** `operator_id IS NOT NULL`，外发对账查询 `delegate_target_type = 'external'`
